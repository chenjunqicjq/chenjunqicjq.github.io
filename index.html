<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-桥接模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/22/桥接模式/" class="article-date">
  <time datetime="2018-04-22T14:46:03.000Z" itemprop="datePublished">2018-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/22/桥接模式/">桥接模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#include <iostream><br>/*桥接模式：<br>    把抽象和具体的方法实现分离开来，使他们可以独立的变化<br>    如：手机品牌和手机软件是两个概念，不同的手机可以有相同的软件<br>    不同的软件可以安装在相同的手机上。两者都具有很大的变动性并且耦合很大。<br>    如果单独以手机品牌或软件来继承拓展的话，变动非常大。<br>    所以把手机和软件分离开，各自继承拓展，要使用是连接上他们的关联。<br>    eg:要实现用AbstrustA或AbstructB实现TimeA或TimeBf方法<br>    把AbstructA和AbstructB…实现一个基类Abstruct，当要扩展时直接继承<br>    Abstruct类，方便快捷，而且不影响Time类<br>    同理，Time类也一样。</iostream></p>
<p>*/</p>
<p>using namespace std;<br> class TimeBasic{<br> public :<br>     TimeBasic(){<br>     cout&lt;&lt;”TimeBasic 构造”&lt;&lt;endl;<br>     }<br>     virtual void operatora()=0;<br> };<br> class TimeA :public TimeBasic{<br> public :<br>     TimeA(){<br>     cout&lt;&lt;”TimeA 构造”&lt;&lt;endl;<br>     }<br>     void operatora(){<br>       cout&lt;&lt;”operatora A  A!!”&lt;&lt;endl;<br>       }<br>};<br>class TimeB :public TimeBasic{<br> public :<br>     TimeB(){<br>     cout&lt;&lt;”TimeB 构造”&lt;&lt;endl;<br>     }<br>     void operatora(){<br>       cout&lt;&lt;”operatora B  B!!”&lt;&lt;endl;<br>       }<br>};<br>class AbstructBasic {<br>    protected:<br>        TimeBasic * TB;<br>    public :<br>        virtual void operatora(){<br>           TB-&gt;operatora();<br>        };<br>    };</p>
<p> class AbstructA :public AbstructBasic{<br>   public:<br>       AbstructA(TimeBasic <em>t){<br>         TB=t;<br>         cout&lt;&lt;”AbstructA 构造”&lt;&lt;endl;<br>        }<br> };<br> class AbstructB :public AbstructBasic{<br>     public:<br>       AbstructB(TimeBasic </em>t){<br>            TB=t;<br>            cout &lt;&lt;”AbstructB 构造”&lt;&lt;endl;<br>       }</p>
<p> };</p>
<p>int main()<br>{<br>    //创建一个TimeA对象，指针ta指向该对象<br>    /<em><br>    创建一个AbstructB对象，并让AbstructBasci基类指针指向他<br>    创建AbstructB对象时，构造函数把ta赋值给TimeBasic指针TB，<br>    AB调用operatora方法，AbstructBasic的operatora方法又调用<br>    TB所指向的对象的operatora方法
    </em>/<br>    TimeA <em>ta=new TimeA();<br>    AbstructBasic </em>AB=new AbstructB(ta);<br>    AB-&gt;operatora();<br>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/22/桥接模式/" data-id="cjgaz49er0006dcuiqv8xc6d0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-模板模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/20/模板模式/" class="article-date">
  <time datetime="2018-04-20T14:19:42.000Z" itemprop="datePublished">2018-04-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/20/模板模式/">模板模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>模板模式<br>定义一个操作中的算法骨架，而将一些步骤延迟到子类中实现。模板方法使得子类可以再不改变一个算法的结构即可重新定义该算法的某些特定步骤。通过把不变的行为搬移到基类中，去除了子类的重复代码，提供了一个很好的代码复用解决方案。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/20/模板模式/" data-id="cjgaz49eg0005dcuiqw0yu41v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ArrayList源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/14/ArrayList源码分析/" class="article-date">
  <time datetime="2018-04-13T16:36:33.000Z" itemprop="datePublished">2018-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/14/ArrayList源码分析/">ArrayList源码分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>public class ArrayList<e> extends AbstractList<e><br>        implements List<e>, RandomAccess, Cloneable, java.io.Serializable<br>{<br>    private static final long serialVersionUID = 8683452581122892189L;<br>    //默认初始容量<br>    private static final int DEFAULT_CAPACITY = 10;<br>    //默认空构造，当elementDate==EMPTY_ELEMENTDATA时，首次添加元素会使大小扩容到DEFAULT_CAPACITY。<br>    private static final Object[] EMPTY_ELEMENTDATA = {};<br>    //transient关键字使不对该区域序列化，ArratList内部重写了序列化/反序列化<br>    transient Object[] elementData; // non-private to simplify nested class access<br>    //数组的大小<br>    private int size;<br>    //指定大小的初始化<br>    public ArrayList(int initialCapacity) {<br>        super();<br>        if (initialCapacity &lt; 0)<br>            throw new IllegalArgumentException(“Illegal Capacity: “+<br>                                               initialCapacity);<br>        this.elementData = new Object[initialCapacity];<br>    }<br>    //按照EMPTY_ELEMENTDATA初始化，<br>    //实际并没有建立缓冲区，在添加第一个元素使扩容到DEFAULT_CAPACITY<br>    public ArrayList() {<br>        super();<br>        this.elementData = EMPTY_ELEMENTDATA;<br>    }<br>    //根据其他集合对象创建<br>    public ArrayList(Collection&lt;? extends E&gt; c) {<br>        elementData = c.toArray();<br>        size = elementData.length;<br>        // c.toArray might (incorrectly) not return Object[] (see 6260652)<br>        //当toArray返回类型不是Object类时，通过copyOf进行强转<br>        if (elementData.getClass() != Object[].class)<br>            elementData = Arrays.copyOf(elementData, size, Object[].class);<br>    }<br>    //修剪大小，把数组内多余的空位减去，<br>    //如数组长度为10，但只有4个值，调用该方法把空余的6个位置剪去<br>    public void trimToSize() {<br>        modCount++;<br>        if (size &lt; elementData.length) {<br>            elementData = Arrays.copyOf(elementData, size);<br>        }<br>    }</e></e></e></p>
<pre><code>public void ensureCapacity(int minCapacity) {
    int minExpand = (elementData != EMPTY_ELEMENTDATA）? 0: DEFAULT_CAPACITY;

    if (minCapacity &gt; minExpand) {
        ensureExplicitCapacity(minCapacity);
    }
}
 //确认内部容量
private void ensureCapacityInternal(int minCapacity) {
    // 对于默认构造器创建的实例, 保证容量不小于DEFAULT_CAPACITY
    if (elementData == EMPTY_ELEMENTDATA) {
        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
    }

    ensureExplicitCapacity(minCapacity);
}
 //确认扩展容量
private void ensureExplicitCapacity(int minCapacity) {
    //记录结构变化的次数
    modCount++;
    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity);
}
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
 //扩容
private void grow(int minCapacity) {
    int oldCapacity = elementData.length;
    //计算扩容后的容量，默认为以前的1.5倍
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    //新容量小于老的大小，则把老的大小作为新的容量大小
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    //新容量超过最大值，大于数组最大值，则返回Integer.MAX_VALUE
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    //把以前的数组复制进扩容后的数组
    elementData = Arrays.copyOf(elementData, newCapacity);
}

private static int hugeCapacity(int minCapacity) {
    if (minCapacity &lt; 0) // overflow
        throw new OutOfMemoryError();
    return (minCapacity &gt; MAX_ARRAY_SIZE) ?
        Integer.MAX_VALUE :
        MAX_ARRAY_SIZE;
}

public int size() {
    return size;
}


public boolean isEmpty() {
    return size == 0;
}

public boolean contains(Object o) {
    return indexOf(o) &gt;= 0;
}

 //查找元素的下标
public int indexOf(Object o) {
    if (o == null) {
        for (int i = 0; i &lt; size; i++)
            if (elementData[i]==null)
                return i;
    } else {
        for (int i = 0; i &lt; size; i++)
            if (o.equals(elementData[i]))
                return i;
    }
    return -1;
}

public int lastIndexOf(Object o) {
    if (o == null) {
        for (int i = size-1; i &gt;= 0; i--)
            if (elementData[i]==null)
                return i;
    } else {
        for (int i = size-1; i &gt;= 0; i--)
            if (o.equals(elementData[i]))
                return i;
    }
    return -1;
}

//克隆
public Object clone() {
    try {
        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();
        v.elementData = Arrays.copyOf(elementData, size);
        v.modCount = 0;
        return v;
    } catch (CloneNotSupportedException e) {
        // this shouldn&apos;t happen, since we are Cloneable
        throw new InternalError(e);
    }
}

//把ArrayList转化为数组
public Object[] toArray() {
    return Arrays.copyOf(elementData, size);
}
 //把集合转化为数组
@SuppressWarnings(&quot;unchecked&quot;)
public &lt;T&gt; T[] toArray(T[] a) {
    if (a.length &lt; size)
        // Make a new array of a&apos;s runtime type, but my contents:
        return (T[]) Arrays.copyOf(elementData, size, a.getClass());
    System.arraycopy(elementData, 0, a, 0, size);
    if (a.length &gt; size)
        a[size] = null;
    return a;
}

// Positional Access Operations
//访问index位置的元素
@SuppressWarnings(&quot;unchecked&quot;)
E elementData(int index) {
    return (E) elementData[index];
}

/**
 * Returns the element at the specified position in this list.
 *
 * @param  index index of the element to return
 * @return the element at the specified position in this list
 * @throws IndexOutOfBoundsException {@inheritDoc}
 */
public E get(int index) {
    //检查是否超过数组大小
    rangeCheck(index);

    return elementData(index);
}
 //修改某位置的元素。结构未改变，modcount不用改变
public E set(int index, E element) {
    rangeCheck(index);

    E oldValue = elementData(index);
    elementData[index] = element;
    return oldValue;
}
 //添加元素
public boolean add(E e) {
    //检查是否超过数组大小，超过则扩容
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}

//添加元素到指定位置，添加后，原数组从该位置依次往后移动位置
//例：1357   add(1,9)
//    19357
public void add(int index, E element) {
    rangeCheckForAdd(index);

    ensureCapacityInternal(size + 1);  // Increments modCount!!
    System.arraycopy(elementData, index, elementData, index + 1,
                     size - index);
    elementData[index] = element;
    size++;
}
//删除指定位置的元素，数据结构改变，元素删除后，后面的元素依次往前移
public E remove(int index) {
    rangeCheck(index);

    modCount++;
    E oldValue = elementData(index);

    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    //数组大小减一
    elementData[--size] = null; // clear to let GC do its work

    return oldValue;
}
//删除指定元素
public boolean remove(Object o) {
    if (o == null) {
        for (int index = 0; index &lt; size; index++)
            if (elementData[index] == null) {
                fastRemove(index);
                return true;
            }
    } else {
        for (int index = 0; index &lt; size; index++)
            if (o.equals(elementData[index])) {
                fastRemove(index);
                return true;
            }
    }
    return false;
}

private void fastRemove(int index) {
    modCount++;
    int numMoved = size - index - 1;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    elementData[--size] = null; // clear to let GC do its work
}
//清除数组
public void clear() {
    modCount++;


    for (int i = 0; i &lt; size; i++)
        elementData[i] = null;

    size = 0;
}

//在数组尾部添加集合元素
public boolean addAll(Collection&lt;? extends E&gt; c) {
    Object[] a = c.toArray();
    int numNew = a.length;
    ensureCapacityInternal(size + numNew);  // Increments modCount
    System.arraycopy(a, 0, elementData, size, numNew);
    size += numNew;
    return numNew != 0;
}

 //添加集合到指定位置
public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
    rangeCheckForAdd(index);

    Object[] a = c.toArray();
    int numNew = a.length;
    ensureCapacityInternal(size + numNew);  // Increments modCount

    int numMoved = size - index;
    if (numMoved &gt; 0)
        System.arraycopy(elementData, index, elementData, index + numNew,
                         numMoved);

    System.arraycopy(a, 0, elementData, index, numNew);
    size += numNew;
    return numNew != 0;
}

//删除一段指定位置的元素
protected void removeRange(int fromIndex, int toIndex) {
    modCount++;
    int numMoved = size - toIndex;
    System.arraycopy(elementData, toIndex, elementData, fromIndex,
                     numMoved);

    // clear to let GC do its work
    int newSize = size - (toIndex-fromIndex);
    for (int i = newSize; i &lt; size; i++) {
        elementData[i] = null;
    }
    size = newSize;
}

private void rangeCheck(int index) {
    if (index &gt;= size)
        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
}

private void rangeCheckForAdd(int index) {
    if (index &gt; size || index &lt; 0)
        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
}

private String outOfBoundsMsg(int index) {
    return &quot;Index: &quot;+index+&quot;, Size: &quot;+size;
}
//移除所有包含在容器c中的元素
public boolean removeAll(Collection&lt;?&gt; c) {
    Objects.requireNonNull(c);
    //注意这的false
    return batchRemove(c, false);
}
//移除所有不包含在容器c中的元素
public boolean retainAll(Collection&lt;?&gt; c) {
    Objects.requireNonNull(c);
    return batchRemove(c, true);
}

private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) {
    final Object[] elementData = this.elementData;
    int r = 0, w = 0;
    boolean modified = false;
    try {
        for (; r &lt; size; r++)
        //根据传入的complement值的不同，把需要保留的元素移到数组的前部
            if (c.contains(elementData[r]) == complement)
                elementData[w++] = elementData[r];
    } finally {
        //即使c.contains抛出异常，任然执行操作
        //r!=size 说明有异常，则把从异常位置后的元素都放入数组
        if (r != size) {
            System.arraycopy(elementData, r,
                             elementData, w,
                             size - r);
            w += size - r;
        }
        //w!=size 说明有元素被删除，则把数组后面的元素都赋空
        if (w != size) {
            // clear to let GC do its work
            for (int i = w; i &lt; size; i++)
                elementData[i] = null;
            modCount += size - w;
            size = w;
            modified = true;
        }
    }
    return modified;
}

/**
 * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that
 * is, serialize it).
 *
 * @serialData The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt;
 *             instance is emitted (int), followed by all of its elements
 *             (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order.
 */
private void writeObject(java.io.ObjectOutputStream s)
    throws java.io.IOException{
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;
    s.defaultWriteObject();

    // Write out size as capacity for behavioural compatibility with clone()
    s.writeInt(size);

    // Write out all elements in the proper order.
    for (int i=0; i&lt;size; i++) {
        s.writeObject(elementData[i]);
    }

    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}

/**
 * Reconstitute the &lt;tt&gt;ArrayList&lt;/tt&gt; instance from a stream (that is,
 * deserialize it).
 */
private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException {
    elementData = EMPTY_ELEMENTDATA;

    // Read in size, and any hidden stuff
    s.defaultReadObject();

    // Read in capacity
    s.readInt(); // ignored

    if (size &gt; 0) {
        // be like clone(), allocate array based upon size not capacity
        ensureCapacityInternal(size);

        Object[] a = elementData;
        // Read in all elements in the proper order.
        for (int i=0; i&lt;size; i++) {
            a[i] = s.readObject();
        }
    }
}


public ListIterator&lt;E&gt; listIterator(int index) {
    if (index &lt; 0 || index &gt; size)
        throw new IndexOutOfBoundsException(&quot;Index: &quot;+index);
    return new ListItr(index);
}

public ListIterator&lt;E&gt; listIterator() {
    return new ListItr(0);
}

public Iterator&lt;E&gt; iterator() {
    return new Itr();
}


private class Itr implements Iterator&lt;E&gt; {
    //游标，表示下一个元素的索引位置
    int cursor;       // index of next element to return
    //游标，表示上一个元素的索引位置
    int lastRet = -1; // index of last element returned; -1 if no such
    int expectedModCount = modCount;
    //判断是否有下一个元素
    public boolean hasNext() {
        return cursor != size;
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    //返回下一个元素
    public E next() {
        checkForComodification();
        int i = cursor;
        //如果大于元素个数，则找不到
        if (i &gt;= size)
            throw new NoSuchElementException();
        Object[] elementData = ArrayList.this.elementData;
        //如果大于数组长度
        if (i &gt;= elementData.length)
            throw new ConcurrentModificationException();
        cursor = i + 1;
        return (E) elementData[lastRet = i];
    }
    //删除集合上一次next方法返回的元素
    public void remove() {
        if (lastRet &lt; 0)
            throw new IllegalStateException();
        checkForComodification();

        try {
            ArrayList.this.remove(lastRet);
            cursor = lastRet;
            lastRet = -1;
            expectedModCount = modCount;
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void forEachRemaining(Consumer&lt;? super E&gt; consumer) {
        Objects.requireNonNull(consumer);
        final int size = ArrayList.this.size;
        int i = cursor;
        if (i &gt;= size) {
            return;
        }
        final Object[] elementData = ArrayList.this.elementData;
        if (i &gt;= elementData.length) {
            throw new ConcurrentModificationException();
        }
        while (i != size &amp;&amp; modCount == expectedModCount) {
            consumer.accept((E) elementData[i++]);
        }
        // update once at end of iteration to reduce heap write traffic
        cursor = i;
        lastRet = i - 1;
        checkForComodification();
    }

    final void checkForComodification() {
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
    }
}

/**
 * An optimized version of AbstractList.ListItr
 */
private class ListItr extends Itr implements ListIterator&lt;E&gt; {
    ListItr(int index) {
        super();
        cursor = index;
    }

    public boolean hasPrevious() {
        return cursor != 0;
    }
    //下一个元素下标
    public int nextIndex() {
        return cursor;
    }
    //上一个元素下标
    //从return内容可以验证，在遍历时，游标cursor并不是直接指在元素下
    //而是停留在两个元素中间
    public int previousIndex() {
        return cursor - 1;
    }
    //返回前一个元素
    @SuppressWarnings(&quot;unchecked&quot;)
    public E previous() {
        checkForComodification();
        int i = cursor - 1;
        if (i &lt; 0)
            throw new NoSuchElementException();
        Object[] elementData = ArrayList.this.elementData;
        if (i &gt;= elementData.length)
            throw new ConcurrentModificationException();
        cursor = i;
        return (E) elementData[lastRet = i];
    }
    //替换上一次操作的元素
    public void set(E e) {
        if (lastRet &lt; 0)
            throw new IllegalStateException();
        checkForComodification();

        try {
            ArrayList.this.set(lastRet, e);
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }
    //在上一次操作的元素后添加一个元素
    public void add(E e) {
        checkForComodification();

        try {
            int i = cursor;
            ArrayList.this.add(i, e);
            cursor = i + 1;
            lastRet = -1;
            expectedModCount = modCount;
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }
}

/**
 * Returns a view of the portion of this list between the specified
 * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.  (If
 * {@code fromIndex} and {@code toIndex} are equal, the returned list is
 * empty.)  The returned list is backed by this list, so non-structural
 * changes in the returned list are reflected in this list, and vice-versa.
 * The returned list supports all of the optional list operations.
 *
 * &lt;p&gt;This method eliminates the need for explicit range operations (of
 * the sort that commonly exist for arrays).  Any operation that expects
 * a list can be used as a range operation by passing a subList view
 * instead of a whole list.  For example, the following idiom
 * removes a range of elements from a list:
 * &lt;pre&gt;
 *      list.subList(from, to).clear();
 * &lt;/pre&gt;
 * Similar idioms may be constructed for {@link #indexOf(Object)} and
 * {@link #lastIndexOf(Object)}, and all of the algorithms in the
 * {@link Collections} class can be applied to a subList.
 *
 * &lt;p&gt;The semantics of the list returned by this method become undefined if
 * the backing list (i.e., this list) is &lt;i&gt;structurally modified&lt;/i&gt; in
 * any way other than via the returned list.  (Structural modifications are
 * those that change the size of this list, or otherwise perturb it in such
 * a fashion that iterations in progress may yield incorrect results.)
 *
 * @throws IndexOutOfBoundsException {@inheritDoc}
 * @throws IllegalArgumentException {@inheritDoc}
 */
public List&lt;E&gt; subList(int fromIndex, int toIndex) {
    subListRangeCheck(fromIndex, toIndex, size);
    //子序列是左闭右开
    return new SubList(this, 0, fromIndex, toIndex);
}

static void subListRangeCheck(int fromIndex, int toIndex, int size) {
    if (fromIndex &lt; 0)
        throw new IndexOutOfBoundsException(&quot;fromIndex = &quot; + fromIndex);
    if (toIndex &gt; size)
        throw new IndexOutOfBoundsException(&quot;toIndex = &quot; + toIndex);
    if (fromIndex &gt; toIndex)
        throw new IllegalArgumentException(&quot;fromIndex(&quot; + fromIndex +
                                           &quot;) &gt; toIndex(&quot; + toIndex + &quot;)&quot;);
}

private class SubList extends AbstractList&lt;E&gt; implements RandomAccess {
    private final AbstractList&lt;E&gt; parent;
    private final int parentOffset;//父集合的起始位置
    private final int offset;//原对象的起始位置
    int size;

    SubList(AbstractList&lt;E&gt; parent,
            int offset, int fromIndex, int toIndex) {
        //引用父对象，一直引用，导致不能被回收，占用内存，容易造成内存溢出
        this.parent = parent;
        this.parentOffset = fromIndex;
        this.offset = offset + fromIndex;
        this.size = toIndex - fromIndex;
        this.modCount = ArrayList.this.modCount;
    }

    public E set(int index, E e) {
        //判断大小是否异常
        rangeCheck(index);
        //判断结构是否被改变
        checkForComodification();
        E oldValue = ArrayList.this.elementData(offset + index);
        ArrayList.this.elementData[offset + index] = e;
        return oldValue;
    }

    public E get(int index) {
        rangeCheck(index);
        checkForComodification();
        return ArrayList.this.elementData(offset + index);
    }

    public int size() {
        checkForComodification();
        return this.size;
    }
    //添加一个元素到指定位置，
    //子序列改变结构，引起父序列改变
    public void add(int index, E e) {
        rangeCheckForAdd(index);
        checkForComodification();
        parent.add(parentOffset + index, e);
        this.modCount = parent.modCount;
        this.size++;
    }
    //移除指定元素
    public E remove(int index) {
        rangeCheck(index);
        checkForComodification();
        E result = parent.remove(parentOffset + index);
        this.modCount = parent.modCount;
        this.size--;
        return result;
    }
    //移除一段元素
    protected void removeRange(int fromIndex, int toIndex) {
        checkForComodification();
        parent.removeRange(parentOffset + fromIndex,
                           parentOffset + toIndex);
        this.modCount = parent.modCount;
        this.size -= toIndex - fromIndex;
    }
    //添加一个容器到子序列中
    public boolean addAll(Collection&lt;? extends E&gt; c) {
        return addAll(this.size, c);
    }

    public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
        rangeCheckForAdd(index);
        int cSize = c.size();
        if (cSize==0)
            return false;

        checkForComodification();
        parent.addAll(parentOffset + index, c);
        this.modCount = parent.modCount;
        this.size += cSize;
        return true;
    }

    public Iterator&lt;E&gt; iterator() {
        return listIterator();
    }
    //子序列的迭代器，在一个内部类中实现，代码和父集合基本一致
    public ListIterator&lt;E&gt; listIterator(final int index) {
        checkForComodification();
        rangeCheckForAdd(index);
        final int offset = this.offset;

        return new ListIterator&lt;E&gt;() {
            int cursor = index;
            int lastRet = -1;
            int expectedModCount = ArrayList.this.modCount;

            public boolean hasNext() {
                return cursor != SubList.this.size;
            }

            @SuppressWarnings(&quot;unchecked&quot;)
            public E next() {
                checkForComodification();
                int i = cursor;
                if (i &gt;= SubList.this.size)
                    throw new NoSuchElementException();
                Object[] elementData = ArrayList.this.elementData;
                if (offset + i &gt;= elementData.length)
                    throw new ConcurrentModificationException();
                cursor = i + 1;
                return (E) elementData[offset + (lastRet = i)];
            }

            public boolean hasPrevious() {
                return cursor != 0;
            }

            @SuppressWarnings(&quot;unchecked&quot;)
            public E previous() {
                checkForComodification();
                int i = cursor - 1;
                if (i &lt; 0)
                    throw new NoSuchElementException();
                Object[] elementData = ArrayList.this.elementData;
                if (offset + i &gt;= elementData.length)
                    throw new ConcurrentModificationException();
                cursor = i;
                return (E) elementData[offset + (lastRet = i)];
            }

            @SuppressWarnings(&quot;unchecked&quot;)
            public void forEachRemaining(Consumer&lt;? super E&gt; consumer) {
                Objects.requireNonNull(consumer);
                final int size = SubList.this.size;
                int i = cursor;
                if (i &gt;= size) {
                    return;
                }
                final Object[] elementData = ArrayList.this.elementData;
                if (offset + i &gt;= elementData.length) {
                    throw new ConcurrentModificationException();
                }
                while (i != size &amp;&amp; modCount == expectedModCount) {
                    consumer.accept((E) elementData[offset + (i++)]);
                }
                // update once at end of iteration to reduce heap write traffic
                lastRet = cursor = i;
                checkForComodification();
            }

            public int nextIndex() {
                return cursor;
            }

            public int previousIndex() {
                return cursor - 1;
            }

            public void remove() {
                if (lastRet &lt; 0)
                    throw new IllegalStateException();
                checkForComodification();

                try {
                    SubList.this.remove(lastRet);
                    cursor = lastRet;
                    lastRet = -1;
                    expectedModCount = ArrayList.this.modCount;
                } catch (IndexOutOfBoundsException ex) {
                    throw new ConcurrentModificationException();
                }
            }

            public void set(E e) {
                if (lastRet &lt; 0)
                    throw new IllegalStateException();
                checkForComodification();

                try {
                    ArrayList.this.set(offset + lastRet, e);
                } catch (IndexOutOfBoundsException ex) {
                    throw new ConcurrentModificationException();
                }
            }

            public void add(E e) {
                checkForComodification();

                try {
                    int i = cursor;
                    SubList.this.add(i, e);
                    cursor = i + 1;
                    lastRet = -1;
                    expectedModCount = ArrayList.this.modCount;
                } catch (IndexOutOfBoundsException ex) {
                    throw new ConcurrentModificationException();
                }
            }

            final void checkForComodification() {
                if (expectedModCount != ArrayList.this.modCount)
                    throw new ConcurrentModificationException();
            }
        };
    }

    public List&lt;E&gt; subList(int fromIndex, int toIndex) {
        subListRangeCheck(fromIndex, toIndex, size);
        return new SubList(this, offset, fromIndex, toIndex);
    }

    private void rangeCheck(int index) {
        if (index &lt; 0 || index &gt;= this.size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    private void rangeCheckForAdd(int index) {
        if (index &lt; 0 || index &gt; this.size)
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    private String outOfBoundsMsg(int index) {
        return &quot;Index: &quot;+index+&quot;, Size: &quot;+this.size;
    }

    private void checkForComodification() {
        if (ArrayList.this.modCount != this.modCount)
            throw new ConcurrentModificationException();
    }

    public Spliterator&lt;E&gt; spliterator() {
        checkForComodification();
        return new ArrayListSpliterator&lt;E&gt;(ArrayList.this, offset,
                                           offset + this.size, this.modCount);
    }
}
//forEach
//就是一个for循环
@Override
public void forEach(Consumer&lt;? super E&gt; action) {
    Objects.requireNonNull(action);
    final int expectedModCount = modCount;
    @SuppressWarnings(&quot;unchecked&quot;)
    final E[] elementData = (E[]) this.elementData;
    final int size = this.size;
    for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) {
        action.accept(elementData[i]);
    }
    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
}

@Override
public Spliterator&lt;E&gt; spliterator() {
    return new ArrayListSpliterator&lt;&gt;(this, 0, -1, 0);
}

/** Index-based split-by-two, lazily initialized Spliterator */
//基于索引，二分的分割器
static final class ArrayListSpliterator&lt;E&gt; implements Spliterator&lt;E&gt; {


    private final ArrayList&lt;E&gt; list;
    //起始位置
    private int index; // current index, modified on advance/split
    //结束位置，-1表示到最后一个元素
    //二分，左闭右开序列
    private int fence; // -1 until used; then one past last index
    private int expectedModCount; // initialized when fence set
    ArrayListSpliterator(ArrayList&lt;E&gt; list, int origin, int fence,
                         int expectedModCount) {
        this.list = list; 
        this.index = origin;
        this.fence = fence;
        this.expectedModCount = expectedModCount;
    }
    //第一次使用时实例化结束位置
    private int getFence() { // initialize fence to size on first use
        int hi; // (a specialized variant appears in method forEach)
        ArrayList&lt;E&gt; lst;
        if ((hi = fence) &lt; 0) {
        //只有在第一次时fence&lt;0;
            if ((lst = list) == null)
            //如果list集合中没有元素
                hi = fence = 0;
            else {
                expectedModCount = lst.modCount;
                hi = fence = lst.size;
            }
        }
        return hi;
    }

    public ArrayListSpliterator&lt;E&gt; trySplit() {
        //递归，满足条件，再二分，类似于分治思想
        int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;
        return (lo &gt;= mid) ? null :new ArrayListSpliterator&lt;E&gt;(list, lo, index = mid,
                                        expectedModCount);
    }
    //返回true 时，只表示可能还有元素未处理
    //返回false 时，没有剩余元素处理了
    public boolean tryAdvance(Consumer&lt;? super E&gt; action) {
        if (action == null)
            throw new NullPointerException();
        int hi = getFence(), i = index;
        if (i &lt; hi) {
            index = i + 1;
            @SuppressWarnings(&quot;unchecked&quot;) 
            //取出元素
            E e = (E)list.elementData[i];
            //给Consumer类函数
            action.accept(e);
            if (list.modCount != expectedModCount)
                throw new ConcurrentModificationException();
            return true;
        }
        return false;
    }
    //顺序遍历处理所有剩下的元素
    //Consumer类型，传入值处理
    public void forEachRemaining(Consumer&lt;? super E&gt; action) {
        int i, hi, mc; // hoist accesses and checks from loop
        ArrayList&lt;E&gt; lst;
        Object[] a;
        if (action == null)
            throw new NullPointerException();
        //list集合不为空且元素不为空
        if ((lst = list) != null &amp;&amp; (a = lst.elementData) != null) {
            //第一次使用时实例化时小于0；初始化
            if ((hi = fence) &lt; 0) {
                mc = lst.modCount;
                hi = lst.size;
            }
            else
                mc = expectedModCount;
            if ((i = index) &gt;= 0 &amp;&amp; (index = hi) &lt;= a.length) {
                for (; i &lt; hi; ++i) {
                    @SuppressWarnings(&quot;unchecked&quot;) 
                    E e = (E) a[i];
                    action.accept(e);
                }
                if (lst.modCount == mc)
                    return;
            }
        }
        throw new ConcurrentModificationException();
    }
    //估算大小
    public long estimateSize() {
        return (long) (getFence() - index);
    }
     //打上特征值：、可以返回size
    public int characteristics() {
        //命令|大小|子序列大小
        return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;
    }
}

@Override
public boolean removeIf(Predicate&lt;? super E&gt; filter) {
    Objects.requireNonNull(filter);
    // figure out which elements are to be removed
    // any exception thrown from the filter predicate at this stage
    // will leave the collection unmodified
    int removeCount = 0;
    final BitSet removeSet = new BitSet(size);
    final int expectedModCount = modCount;
    final int size = this.size;
    for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) {
        @SuppressWarnings(&quot;unchecked&quot;)
        final E element = (E) elementData[i];
        //如果满足条件，则放入set中，删除元素个数加一
        if (filter.test(element)) {
            removeSet.set(i);
            removeCount++;
        }
    }
    //判断外部是否修改
    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }

    // shift surviving elements left over the spaces left by removed elements
    //如果有移除元素
    final boolean anyToRemove = removeCount &gt; 0;
    if (anyToRemove) {
        final int newSize = size - removeCount;
        for (int i=0, j=0; (i &lt; size) &amp;&amp; (j &lt; newSize); i++, j++) {
            i = removeSet.nextClearBit(i);
            elementData[j] = elementData[i];
        }
        //将空元素置空
        for (int k=newSize; k &lt; size; k++) {
            elementData[k] = null;  // Let gc do its work
        }
        this.size = newSize;
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
        modCount++;
    }

    return anyToRemove;
}
//UnaryOperator 接受一个什么类型的参数，返回一个什么类型的参数
//对数组中的每一个元素进行一系列的操作，返回同样的元素，
//如果 List&lt;Student&gt; lists  将list集合中的每一个student姓名改为张三
//使用这个方法就非常方便
@Override
@SuppressWarnings(&quot;unchecked&quot;)
public void replaceAll(UnaryOperator&lt;E&gt; operator) {
    Objects.requireNonNull(operator);
    final int expectedModCount = modCount;
    final int size = this.size;
    for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) {
        //取出每一个元素给operator的apply方法
        elementData[i] = operator.apply((E) elementData[i]);
    }
    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
    modCount++;
}
//排序
@Override
@SuppressWarnings(&quot;unchecked&quot;)
public void sort(Comparator&lt;? super E&gt; c) {
    final int expectedModCount = modCount;
    Arrays.sort((E[]) elementData, 0, size, c);
    if (modCount != expectedModCount) {
        throw new ConcurrentModificationException();
    }
    modCount++;
}
</code></pre><p>}</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/14/ArrayList源码分析/" data-id="cjgaz49e30000dcuionjse03y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HashMap源码部分分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/06/HashMap源码部分分析/" class="article-date">
  <time datetime="2018-04-06T10:56:55.000Z" itemprop="datePublished">2018-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/06/HashMap源码部分分析/">HashMap分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>//继承了AbstractMap类，实现了Map,Cloneable,Serializable类<br>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;<br>    implements Map&lt;K,V&gt;, Cloneable, Serializable {</p>
<pre><code>private static final long serialVersionUID = 362498820763181265L;
//初始化容量默认16，且必须为2的倍数
static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16
//最大容量为2的30 次方，如果传入的数大于这个数，还是被这个数代替
static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;
//加载因子，默认0.75，可以更改
static final float DEFAULT_LOAD_FACTOR = 0.75f;
//链表转红黑树的临界值
static final int TREEIFY_THRESHOLD = 8;
//红黑树转为链表的临界值
static final int UNTREEIFY_THRESHOLD = 6;
//桶可能转为树形结构的最小容量的临界值
static final int MIN_TREEIFY_CAPACITY = 64;


static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    final int hash;
    final K key;
    V value;
    Node&lt;K,V&gt; next;

    Node(int hash, K key, V value, Node&lt;K,V&gt; next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }

    public final K getKey()        { return key; }
    public final V getValue()      { return value; }
    public final String toString() { return key + &quot;=&quot; + value; }

    public final int hashCode() {
        return Objects.hashCode(key) ^ Objects.hashCode(value);
    }

    public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }

    public final boolean equals(Object o) {
        if (o == this)
            return true;
        if (o instanceof Map.Entry) {
            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
            if (Objects.equals(key, e.getKey()) &amp;&amp;
                Objects.equals(value, e.getValue()))
                return true;
        }
        return false;
    }
}

/* ---------------- Static utilities -------------- */


static final int hash(Object key) {
    //h=key.hashCode取哈希值
    //h^(h&gt;&gt;&gt;16) 高位运算
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}

static Class&lt;?&gt; comparableClassFor(Object x) {
    if (x instanceof Comparable) {
        Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;
        if ((c = x.getClass()) == String.class) // bypass checks
            return c;
        if ((ts = c.getGenericInterfaces()) != null) {
            for (int i = 0; i &lt; ts.length; ++i) {
                if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp;
                    ((p = (ParameterizedType)t).getRawType() ==
                     Comparable.class) &amp;&amp;
                    (as = p.getActualTypeArguments()) != null &amp;&amp;
                    as.length == 1 &amp;&amp; as[0] == c) // type arg is c
                    return c;
            }
        }
    }
    return null;
}

/**
 * Returns k.compareTo(x) if x matches kc (k&apos;s screened comparable
 * class), else 0.
 */
@SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;}) // for cast to Comparable
static int compareComparables(Class&lt;?&gt; kc, Object k, Object x) {
    return (x == null || x.getClass() != kc ? 0 :
            ((Comparable)k).compareTo(x));
}
 //判断哈希数组的大小，只能是2 的幂，如传入13，则返回16，
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n &gt;&gt;&gt; 1;
    n |= n &gt;&gt;&gt; 2;
    n |= n &gt;&gt;&gt; 4;
    n |= n &gt;&gt;&gt; 8;
    n |= n &gt;&gt;&gt; 16;
    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}

/* ---------------- Fields -------------- */
//哈希表的链表数组
transient Node&lt;K,V&gt;[] table;
transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;

transient int size;
 //记录HashMap改变的次数
transient int modCount;
 //阈值，判断是否需要调整HashMap的大小，=长度*加载因子
int threshold;
 //实际加载因子
final float loadFactor;
//指定“容量大小”和“负载因子”的构造器
public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity &lt; 0)
        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                           initialCapacity);
    //最大容量只能是2的30次方
    if (initialCapacity &gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                           loadFactor);
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);
}
//指定“容量大小”的构造器
public HashMap(int initialCapacity) {
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}
//默认构造器
public HashMap() {
//设置加载因子
    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
}
</code></pre><p>   //带“子map”的构造器<br>    public HashMap(Map&lt;? extends K, ? extends V&gt; m) {<br>        this.loadFactor = DEFAULT_LOAD_FACTOR;<br>        putMapEntries(m, false);<br>    }</p>
<pre><code>//先哈希表中添加整个集合
final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) {
    int s = m.size();
    if (s &gt; 0) {
      //如果数组为空，则初始化参数
        if (table == null) { // pre-size
            float ft = ((float)s / loadFactor) + 1.0F;
            int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?
                     (int)ft : MAXIMUM_CAPACITY);
            if (t &gt; threshold)
                threshold = tableSizeFor(t);
        }
        //不为空，且超过了阈值，扩容
        else if (s &gt; threshold)
            resize();
        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {
            K key = e.getKey();
            V value = e.getValue();
            //先计算哈希值
            putVal(hash(key), key, value, false, evict);
        }
    }
}


public int size() {
    return size;
}


public boolean isEmpty() {
    return size == 0;
}
</code></pre><p>   //获取key对应的value值<br>    public V get(Object key) {<br>        Node&lt;K,V&gt; e;<br>        return (e = getNode(hash(key), key)) == null ? null : e.value;<br>    }</p>
<pre><code>final Node&lt;K,V&gt; getNode(int hash, Object key) {
    Node&lt;K,V&gt;[] tab; 
    Node&lt;K,V&gt; first, e;
    int n; 
    K k;
    //如果table不为空，长度不为零，该hash值对应的数组的下标的元素不为空
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (first = tab[(n - 1) &amp; hash]) != null) {
        //判断第一个结点是否是目标结点，实则返回
        if (first.hash == hash &amp;&amp; // always check first node
            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
            return first;
        //判断结点是否有下一个
        if ((e = first.next) != null) {
            //判断是否是红黑树，是则用getTreeNode 方法搜索
            if (first instanceof TreeNode)
                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            //如果是链表结果，遍历链表，判断结点是否目标结点
            do {
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    //不符合条件结点，返回null;
    return null;
}
</code></pre><p>   //hashmap是否包含key<br>    public boolean containsKey(Object key) {<br>        return getNode(hash(key), key) != null;<br>    }<br>    //添加<br>    public V put(K key, V value) {<br>        return putVal(hash(key), key, value, false, true);<br>    }</p>
<pre><code>final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node&lt;K,V&gt;[] tab;
    Node&lt;K,V&gt; p; 
    int n, i;
    //判断是否为空，空则创建
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    //判断该值的hash值对应的数组的下标位置是否为空，为空，则把值直接放入
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    //说明该位置已经有值
    else {
        Node&lt;K,V&gt; e; K k;
        //判断头节点是否与传进来的值相等，若相等，e指向链表
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;
        //不相等判断是否为树，是则进去
        else if (p instanceof TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        //则是链表
        else {
            for (int binCount = 0; ; ++binCount) {
                //当最后一个结点为空，创新节点
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                   //判断新加结点后是否转变为树结构
                   if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                //如果遍历中有结点与传的值相同，跳出遍历
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        //说明有相同的值
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            //onlyIfAbsent默认为false,新值把旧值覆盖
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    //结构改变，数值加1
    ++modCount;
    判断现在的大小是否超过阈值，超过则扩容
    if (++size &gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}

final Node&lt;K,V&gt;[] resize() {
    Node&lt;K,V&gt;[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    int newCap, newThr = 0;
    if (oldCap &gt; 0) {
       //如果大于最大值，阈值改为最大值
       if (oldCap &gt;= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        //扩容
        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr &lt;&lt; 1; // double threshold
    }
    //老的长度小于0且老的阈值大于0
    else if (oldThr &gt; 0) // initial capacity was placed in threshold
        newCap = oldThr;
    //都小，初始化，
    else {               // zero initial threshold signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    //计算新的resize上限
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
    table = newTab;
    if (oldTab != null) {
    //把每个桶都移动到新的里面
        for (int j = 0; j &lt; oldCap; ++j) {
            Node&lt;K,V&gt; e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;
                //直接在末尾加一个结点
                if (e.next == null)
                    newTab[e.hash &amp; (newCap - 1)] = e;
                //判断是否为树结构，
                else if (e instanceof TreeNode)
                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                //链表优化
                else { // preserve order
                    Node&lt;K,V&gt; loHead = null, loTail = null;
                    Node&lt;K,V&gt; hiHead = null, hiTail = null;
                    Node&lt;K,V&gt; next;
                    do {
                        next = e.next;
                        //情况1：若结果为0，则挂在lo链上
                        if ((e.hash &amp; oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        //情况2：挂在hi链上
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    //把lo链挂到原来的桶里
                    if (loTail != null) {
                        loTail.next = null;
                        newTab[j] = loHead;
                    }
                    //hi链挂在j+老的桶长度
                    //扩容后计算hash值的结果也会跟着改变
                    if (hiTail != null) {
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}

final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {
    int n, index; Node&lt;K,V&gt; e;
    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)
        resize();
    //链表都改为数
    else if ((e = tab[index = (n - 1) &amp; hash]) != null) {
        TreeNode&lt;K,V&gt; hd = null, tl = null;
        do {
            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);
            if (tl == null)
                hd = p;
            //头节点不为空时
            else {
                p.prev = tl;
                tl.next = p;
            }
            tl = p;
        } while ((e = e.next) != null);
        //将桶中的元素与树的头节点连接起来
        if ((tab[index] = hd) != null)
            hd.treeify(tab);
    }
}


public void putAll(Map&lt;? extends K, ? extends V&gt; m) {
    putMapEntries(m, true);
}
public V remove(Object key) {
    Node&lt;K,V&gt; e;
    return (e = removeNode(hash(key), key, null, false, true)) == null ?
        null : e.value;
}

final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,
                           boolean matchValue, boolean movable) {
    Node&lt;K,V&gt;[] tab;
    Node&lt;K,V&gt; p;
    int n, index;
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (p = tab[index = (n - 1) &amp; hash]) != null) {
       //node存储找到要删除的hash值
       Node&lt;K,V&gt; node = null, e; K k; V v;
        //如果头节点等于要删除的值
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            node = p;
        else if ((e = p.next) != null) {
            //判断是否为树结构，
            if (p instanceof TreeNode)
                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);
            else {
            //链表则循环找，找到则跳出循环
                do {
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key ||
                         (key != null &amp;&amp; key.equals(k)))) {
                        node = e;
                        break;
                    }
                    p = e;
                } while ((e = e.next) != null);
            }
        }
        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||
                             (value != null &amp;&amp; value.equals(v)))) {
            if (node instanceof TreeNode)
                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);
            //删除头节点
            else if (node == p)
                tab[index] = node.next;
            //删除中间结点
            else
                p.next = node.next;
            ++modCount;
            --size;
            afterNodeRemoval(node);
            return node;
        }
    }
    return null;
}
//清除桶
public void clear() {
    Node&lt;K,V&gt;[] tab;
    modCount++;
    if ((tab = table) != null &amp;&amp; size &gt; 0) {
        size = 0;
        for (int i = 0; i &lt; tab.length; ++i)
            tab[i] = null;
    }
}
</code></pre><p>  //通过值V来查找集合中是否有这个值<br>    public boolean containsValue(Object value) {<br>        Node&lt;K,V&gt;[] tab; V v;<br>        if ((tab = table) != null &amp;&amp; size &gt; 0) {<br>            for (int i = 0; i &lt; tab.length; ++i) {<br>                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {<br>                    if ((v = e.value) == value ||<br>                        (value != null &amp;&amp; value.equals(v)))<br>                        return true;<br>                }<br>            }<br>        }<br>        return false;<br>    }<br>常用的几个方法完了，后面的有些复杂，等以后在来补回来    </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/06/HashMap源码部分分析/" data-id="cjgaz49e80001dcuizisaumg2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="poat-sfdsa" class="article article-type-poat" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/31/sfdsa/" class="article-date">
  <time datetime="2018-03-31T07:23:48.000Z" itemprop="datePublished">2018-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/31/sfdsa/">sfdsa</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>jhiluhlihk�ֿ���</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/31/sfdsa/" data-id="cjgaz49ec0003dcui97dy06uj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-又一次" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/31/又一次/" class="article-date">
  <time datetime="2018-03-31T06:10:30.000Z" itemprop="datePublished">2018-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/31/又一次/">又一次</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>啊，苍天，我终于弄好了，</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/31/又一次/" data-id="cjgaz49eb0002dcuimp8pp294" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/31/hello-world/" class="article-date">
  <time datetime="2018-03-31T02:55:34.269Z" itemprop="datePublished">2018-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/31/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/31/hello-world/" data-id="cjgaz49ee0004dcui04wb17wh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/22/桥接模式/">桥接模式</a>
          </li>
        
          <li>
            <a href="/2018/04/20/模板模式/">模板模式</a>
          </li>
        
          <li>
            <a href="/2018/04/14/ArrayList源码分析/">ArrayList源码分析</a>
          </li>
        
          <li>
            <a href="/2018/04/06/HashMap源码部分分析/">HashMap分析</a>
          </li>
        
          <li>
            <a href="/2018/03/31/sfdsa/">sfdsa</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>